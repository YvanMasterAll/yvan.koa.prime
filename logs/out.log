app run at : http://localhost:3001
Executing (default): CREATE TABLE IF NOT EXISTS "user" ("id"  SERIAL  , "name" VARCHAR(255), "password" VARCHAR(255), "avatar" VARCHAR(255) DEFAULT 'https://source.unsplash.com/zBmcEepz5FQ/256x256', "email" VARCHAR(255), "phone" VARCHAR(255), "dept_id" INTEGER , "job_id" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "user"."id" IS 'ID'; COMMENT ON COLUMN "user"."dept_id" IS '部门ID'; COMMENT ON COLUMN "user"."job_id" IS '岗位ID'; COMMENT ON COLUMN "user"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'user' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "role" ("id"  SERIAL  , "name" VARCHAR(255) , "remark" VARCHAR(255) , "scope" VARCHAR(255) , "level" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "role"."id" IS 'ID'; COMMENT ON COLUMN "role"."name" IS '名称'; COMMENT ON COLUMN "role"."remark" IS '备注'; COMMENT ON COLUMN "role"."scope" IS '权限范围'; COMMENT ON COLUMN "role"."level" IS '级别'; COMMENT ON COLUMN "role"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'role' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "dept" ("id"  SERIAL  , "pid" INTEGER , "name" VARCHAR(255) , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "dept"."id" IS 'ID'; COMMENT ON COLUMN "dept"."pid" IS '上级部门'; COMMENT ON COLUMN "dept"."name" IS '名称'; COMMENT ON COLUMN "dept"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'dept' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "job" ("id"  SERIAL  , "name" VARCHAR(255) , "sort" INTEGER DEFAULT 999 , "dept_id" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "job"."id" IS 'ID'; COMMENT ON COLUMN "job"."name" IS '名称'; COMMENT ON COLUMN "job"."sort" IS '排序'; COMMENT ON COLUMN "job"."dept_id" IS '所属部门'; COMMENT ON COLUMN "job"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'job' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "menu" ("id"  SERIAL  , "name" VARCHAR(255) , "path" VARCHAR(255) , "pid" INTEGER , "sort" INTEGER DEFAULT 999 , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "menu"."id" IS 'ID'; COMMENT ON COLUMN "menu"."name" IS '名称'; COMMENT ON COLUMN "menu"."path" IS '路径'; COMMENT ON COLUMN "menu"."pid" IS '上级菜单'; COMMENT ON COLUMN "menu"."sort" IS '排序'; COMMENT ON COLUMN "menu"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'menu' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "permission" ("id"  SERIAL  , "name" VARCHAR(255) , "alias" VARCHAR(255) , "pid" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "permission"."id" IS 'ID'; COMMENT ON COLUMN "permission"."name" IS '名称'; COMMENT ON COLUMN "permission"."alias" IS '别名'; COMMENT ON COLUMN "permission"."pid" IS '上级权限'; COMMENT ON COLUMN "permission"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'permission' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "roles_depts" ("id"  SERIAL  , "role_id" INTEGER , "dept_id" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "roles_depts"."id" IS 'ID'; COMMENT ON COLUMN "roles_depts"."role_id" IS '角色ID'; COMMENT ON COLUMN "roles_depts"."dept_id" IS '部门ID'; COMMENT ON COLUMN "roles_depts"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'roles_depts' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "roles_menus" ("id"  SERIAL  , "role_id" INTEGER , "menu_id" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "roles_menus"."id" IS 'ID'; COMMENT ON COLUMN "roles_menus"."role_id" IS '角色ID'; COMMENT ON COLUMN "roles_menus"."menu_id" IS '菜单ID'; COMMENT ON COLUMN "roles_menus"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'roles_menus' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "roles_permissions" ("id"  SERIAL  , "role_id" INTEGER , "permission_id" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "roles_permissions"."id" IS 'ID'; COMMENT ON COLUMN "roles_permissions"."role_id" IS '角色ID'; COMMENT ON COLUMN "roles_permissions"."permission_id" IS '权限ID'; COMMENT ON COLUMN "roles_permissions"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'roles_permissions' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "users_roles" ("id"  SERIAL  , "role_id" INTEGER , "user_id" INTEGER , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "users_roles"."id" IS 'ID'; COMMENT ON COLUMN "users_roles"."role_id" IS '角色ID'; COMMENT ON COLUMN "users_roles"."user_id" IS '用户ID'; COMMENT ON COLUMN "users_roles"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'users_roles' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
Executing (default): CREATE TABLE IF NOT EXISTS "log" ("id"  SERIAL  , "name" VARCHAR(255) , "description" VARCHAR(255) , "exception_detail" VARCHAR(255) , "log_type" VARCHAR(255) DEFAULT 'success' , "method" VARCHAR(255) , "params" VARCHAR(255) , "request_ip" VARCHAR(255) , "time" INTEGER , "address" VARCHAR(255) , "state" VARCHAR(255) DEFAULT 'on' , "created_at" TIMESTAMP WITH TIME ZONE NOT NULL, "updated_at" TIMESTAMP WITH TIME ZONE NOT NULL, PRIMARY KEY ("id")); COMMENT ON COLUMN "log"."id" IS 'ID'; COMMENT ON COLUMN "log"."name" IS '用户名'; COMMENT ON COLUMN "log"."description" IS '描述信息'; COMMENT ON COLUMN "log"."exception_detail" IS '异常信息'; COMMENT ON COLUMN "log"."log_type" IS '类型'; COMMENT ON COLUMN "log"."method" IS '方法'; COMMENT ON COLUMN "log"."params" IS '参数'; COMMENT ON COLUMN "log"."request_ip" IS 'IP'; COMMENT ON COLUMN "log"."time" IS '耗时'; COMMENT ON COLUMN "log"."address" IS 'IP来源'; COMMENT ON COLUMN "log"."state" IS '状态';
Executing (default): SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND t.relkind = 'r' and t.relname = 'log' GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;
  <-- POST /api/auth/signin?name=test&password=test
Executing (default): SELECT "id", "name", "password", "avatar", "email", "phone", "dept_id", "job_id", "state", "created_at", "updated_at" FROM "user" AS "User" WHERE "User"."name" = 'test' AND "User"."state" = 'on' LIMIT 1;
Executing (default): SELECT "id", "name", "password", "avatar", "email", "phone", "dept_id", "job_id", "state", "created_at", "updated_at" FROM "user" AS "User" WHERE "User"."name" = 'test' AND "User"."password" = 'test' AND "User"."state" = 'on' LIMIT 1;
Executing (default): SELECT "Users_Roles"."id", "Users_Roles"."role_id", "Users_Roles"."user_id", "Users_Roles"."state", "Users_Roles"."created_at", "Users_Roles"."updated_at", "Role"."id" AS "Role.id", "Role"."name" AS "Role.name", "Role"."remark" AS "Role.remark", "Role"."scope" AS "Role.scope", "Role"."level" AS "Role.level", "Role"."state" AS "Role.state", "Role"."created_at" AS "Role.created_at", "Role"."updated_at" AS "Role.updated_at", "Roles_Permissions"."id" AS "Roles_Permissions.id", "Roles_Permissions"."role_id" AS "Roles_Permissions.role_id", "Roles_Permissions"."permission_id" AS "Roles_Permissions.permission_id", "Roles_Permissions"."state" AS "Roles_Permissions.state", "Roles_Permissions"."created_at" AS "Roles_Permissions.created_at", "Roles_Permissions"."updated_at" AS "Roles_Permissions.updated_at", "Roles_Permissions->Permission"."id" AS "Roles_Permissions.Permission.id", "Roles_Permissions->Permission"."name" AS "Roles_Permissions.Permission.name", "Roles_Permissions->Permission"."alias" AS "Roles_Permissions.Permission.alias", "Roles_Permissions->Permission"."pid" AS "Roles_Permissions.Permission.pid", "Roles_Permissions->Permission"."state" AS "Roles_Permissions.Permission.state", "Roles_Permissions->Permission"."created_at" AS "Roles_Permissions.Permission.created_at", "Roles_Permissions->Permission"."updated_at" AS "Roles_Permissions.Permission.updated_at" FROM "users_roles" AS "Users_Roles" INNER JOIN "role" AS "Role" ON "Users_Roles"."role_id" = "Role"."id" AND "Role"."state" = 'on' LEFT OUTER JOIN ( "roles_permissions" AS "Roles_Permissions" INNER JOIN "permission" AS "Roles_Permissions->Permission" ON "Roles_Permissions"."permission_id" = "Roles_Permissions->Permission"."id" AND "Roles_Permissions->Permission"."state" = 'on' ) ON "Users_Roles"."id" = "Roles_Permissions"."role_id" AND "Roles_Permissions"."state" = 'on' WHERE "Users_Roles"."user_id" = 2 AND "Users_Roles"."state" = 'on';
获取到本地缓存: permission_all
Executing (default): SELECT "Roles_Menus"."id", "Roles_Menus"."role_id", "Roles_Menus"."menu_id", "Roles_Menus"."state", "Roles_Menus"."created_at", "Roles_Menus"."updated_at", "Role"."id" AS "Role.id", "Role"."name" AS "Role.name", "Role"."remark" AS "Role.remark", "Role"."scope" AS "Role.scope", "Role"."level" AS "Role.level", "Role"."state" AS "Role.state", "Role"."created_at" AS "Role.created_at", "Role"."updated_at" AS "Role.updated_at", "Menu"."id" AS "Menu.id", "Menu"."name" AS "Menu.name", "Menu"."path" AS "Menu.path", "Menu"."pid" AS "Menu.pid", "Menu"."sort" AS "Menu.sort", "Menu"."state" AS "Menu.state", "Menu"."created_at" AS "Menu.created_at", "Menu"."updated_at" AS "Menu.updated_at" FROM "roles_menus" AS "Roles_Menus" INNER JOIN "role" AS "Role" ON "Roles_Menus"."role_id" = "Role"."id" AND "Role"."state" = 'on' INNER JOIN "menu" AS "Menu" ON "Roles_Menus"."menu_id" = "Menu"."id" AND "Menu"."state" = 'on' WHERE "Roles_Menus"."role_id" IN (2) AND "Roles_Menus"."state" = 'on';
  --> POST /api/auth/signin?name=test&password=test 200 277ms 2.06kb
Executing (default): INSERT INTO "log" ("id","name","description","log_type","method","params","request_ip","time","state","created_at","updated_at") VALUES (DEFAULT,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10) RETURNING *;
